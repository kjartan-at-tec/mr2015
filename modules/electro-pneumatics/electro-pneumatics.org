#+OPTIONS: toc:nil
# #+LaTeX_CLASS: koma-article 

#+LATEX_CLASS: beamer
#+LATEX_CLASS_OPTIONS: [presentation,aspectratio=1610]
#+OPTIONS: H:2

#+LaTex_HEADER: \usepackage{khpreamble}
#+LaTex_HEADER: \usepackage{pgfplots}
#+LaTex_HEADER: \usepackage{pdfpages}
#+LaTex_HEADER: \usepackage{circuitikz}
#+LaTex_HEADER: \usepgfplotslibrary{groupplots}
#+LaTex_HEADER: \usetikzlibrary{positioning,circuits.plc.ladder}
#+LaTex_HEADER: \renewcommand*{\not}[1]{\ensuremath{\bar{#1}}}
#+LaTex_HEADER: \renewcommand*{\not}[1]{\ensuremath{\overline{#1}}}

#+LaTex_HEADER: \newcommand*{\coil}[1]{to[short] ++(0.5, 0) node[coordinate] (orig) {} arc [start angle=180, end angle=150,radius=8mm] (orig) arc [start angle=180, end angle=210,radius=8mm] (orig) ++(1cm, 0) node[coordinate] (coilend) {} arc [start angle=0, end angle=30,radius=8mm] (coilend) arc [start angle=0, end angle=-30,radius=8mm] (coilend) to[short] ++(0.5cm, 0) (orig) ++(0.5, 0.8) node {#1}}

#+title: Logic control of electro-pneumatic systems
# #+date: 2019-03-07

* What do I want the students to understand?			   :noexport:
  - Logic control
  - Boolean algebra
  - Latching circuits

* Which activities will the students do? 			   :noexport:
  1. Simscape implementation and simulation

* Intro    

   
* Logic control and boolean algebra - simple intro example
** Cheese pressing example, sequence A+A-
#+BEGIN_CENTER 
 \includegraphics[width=0.5\linewidth]{../../figures/cheese-stamping.png}
#+END_CENTER
#+begin_export latex
{\tiny From FESTO Didactic}
#+end_export
*** Notes                                                          :noexport:
    - First, I want to introduce this simple pneumatic system to you. It is from the cheese-pressing example, which we have looked at before.
    - We have a single cylinder, named A.
    - The cylinder extends to press a piece of cheese into a mold
    - Then it retracts
    - We want this movement to be repeated, and to be automatic.
    - The sequence we want to generated is denoted A+A-, which is a simple way of expressing what I just said.
    - Our task is to design a logic controller for this system

** A logic control loop
   #+BEGIN_CENTER 
    \includegraphics[width=\linewidth]{../../figures/logic-control-loop}
   #+END_CENTER
*** Notes                                                          :noexport:
    - With this very general block diagram, I want to give you my view of logical control, in order to connect the different themes you have seen in this course.
    - The idea here is that we have a system, for instance a pneumatic system, which is designed to carry out a number of operations in an automatic fashion. And it is our job to design a controller for this system.
    - You can think of the simple system in the previous slide.
    - The system, or plant, as we often call it, can be represented as a discrete-time dynamical system.
      - What this means is that the state of the system is described by a state vector x, 
        which changes at discrete times. The sequence of times is denoted with k.
      - The plant has some dynamics meaning that the state will change from k to k+1, depending
        on its current state, and on the inputs to the system.
      - So in the case of the cheese-presser. What would you say is the state of the system? 
	What is it that changes with time? Write suggestions in chat (to all).
      - The state x consists, as we shall see, of a number of boolean variables, such as cylinder 
	A is retracted/extended
    - The input to the system are the control signals u_k. These are the signals to the solenoids
      controlling the valves. These are also boolean, since each solenoid is either 
      energized (meaning current flowing through its coil), or not energized (no current)
    - Depending on the input, and on the current state of the system, the state will change.  
    - Now the controller is a function which takes information about the state of the system (feedback)
      together with external input, such as switches, start/stop buttons, and decides the input
      signal u.
    - This function written as f(x, u_c), is a boolean function, and this will be implemented using 
      electrial switches and relays in a ladder diagram.

** Cheese pressing example - Variables
Activating solenoid UA+ extends the cylinder, activating  UA- retracts the cylinder.
*** Vars
     :PROPERTIES:
     :BEAMER_col: 0.5
     :END:      
**** State variable
     \[ x = \begin{cases} 0 & \text{Cylinder retracted}\\1 & \text{Cylinder extended}\end{cases}\]
**** Control signal
    \[ u = \begin{bmatrix} u_1\\u_2 \end{bmatrix}, \]
    with
    \begin{align*}
    u_1 &= \begin{cases} 0 & \text{Don't activate UA+}\\1 & \text{Activate UA+ }\end{cases}\\
    u_2 &= \begin{cases} 0 & \text{Don't activate UA-}\\1 & \text{Activate UA-}\end{cases}\\
    \end{align*}

*** Command signal
    :PROPERTIES:
    :BEAMER_col: 0.5
    :END:      

    \includegraphics[width=0.6\linewidth]{../../figures/AplAmin-solenoids.png}
**** Command signal

    \[ u_{c} = \begin{cases} 0 & \text{Button unpushed}\\1 & \text{Button pushed}\end{cases}. \]


*** Notes                                                          :noexport:
    - Going back to the cheese pressing example
    - We define the state variables as
    - And the control signals
    - The pneumatic part is shown here
    - There is also a button controlling the operation. When the button is pressed, 
      the system is operated, when it is not pushed the cylinder should return and 
      stay in the retracted position.
** Cheese pressing example - Plant dynamics and control law
Activating solenoid UA+ extends the cylinder, activating  UA- retracts the cylinder.
*** Plant dynamics \(x_{k+1} = g(x_k, u_k)\)
    :PROPERTIES:
    :BEAMER_col: 0.5
    :BEAMER_env: block
    :END:      

     #+attr_latex: :align |cc|cc|
    |-----------+-----------+-------+-----------|
    |           |           | state |           |
    | $u_{1,k}$ | $u_{2,k}$ | $x_k$ | $x_{k+1}$ |
    |-----------+-----------+-------+-----------|
    |         0 |         0 |     0 |         0 |
    |         0 |         1 |     0 |         0 |
    |         1 |         0 |     0 |         1 |
    |         1 |         1 |     0 |         0 |
    |         0 |         0 |     1 |         1 |
    |         0 |         1 |     1 |         0 |
    |         1 |         0 |     1 |         1 |
    |         1 |         1 |     1 |         1 |
    |-----------+-----------+-------+-----------|
    
#    \begin{align*} 
#      x_{k+1} &= u_{1,k}\not{u_{2,k}}\not{x_k} + \not{u_{1,k}}\not{u_{2,k}}x_k + u_{1,k}\not{u_{2,k}}x_k\\ &=  \not{u_{1,k}}\not{u_{2,k}}x_k + u_{1,k}\not{u_{2,k}}
#    \end{align*}

*** Control law \(u_k = f(x, u_c)\)
    :PROPERTIES:
    :BEAMER_col: 0.5
    :BEAMER_env: block
    :END:      

     #+attr_latex: :align |cc|cc|
     |-----+---------+-------+-------|
     | $x$ | $u_{c}$ | $u_1$ | $u_2$ |
     |-----+---------+-------+-------|
     |   0 |       0 |     0 | 0     |
     |   1 |       0 |     0 | 1     |
     |   0 |       1 |     1 | 0     |
     |   1 |       1 |     0 | 1     |
     |-----+---------+-------+-------|
     
     \begin{align*}
       u_1 &= \qquad\qquad\\
       u_2 &= 
     \end{align*}
#     \begin{align*}
#       u_1 &= \not{x}u_c\\
#       u_2 &= x\not{u_c} + xu_c = x
#     \end{align*}


*** Notes                                                          :noexport:
    - Since the plant dynamics is described by a boolean function, it can be defined in a truth table.
    - The outcome of the function is x_{k+1}, and the inputs are x_k and u_k
    - The dynamics is obvious. If we try to extend the cylinder signal u=[1, 0], then it will extend 
      if not already extended. Not activating any solenoids leave the cylinder in the current position.
      And activating both solenoids will not change the position of the valve, and hence also leave
      it in the same state.
    - Activating both solenoids should be avoided though. If your control law logic does this, then 
      there is something wrong.
    - The control law truth table specifies how u1 and u2 should be chosen, depending on the 
      values of x and uc, or in words, on the state of the cylinder, and the state of the start button.
    - We see that if the cylinder is retracted (x=0), then we should activate u1 (extending the cylinder) only if the start button is pushed. 
    - Take a minute and express the control law as boolean functions, based on the control law
** Cheese pressing example - implementing the control  law

    #+begin_export latex
		\begin{center}
			 \begin{tikzpicture}
			   \node at (-2,0.5) {+24V};
			   \node at (8,0.5) {0V};
			   \draw (-2,0) to[short, o-]  (-2,-3);
			   \draw (8,0) to[short, o-](8,-3);
			   \draw (6, -0.5) \coil{$u_1$};
			   \draw (6,-2.5) \coil{$u_2$};
		      \end{tikzpicture}
		\end{center}
		\begin{center}
		  \begin{tikzpicture}[circuit plc ladder,]
		    \draw(0,0) to [contact NO={info={normally open}}] ++(2,0);
		    \draw(4,0) to [contact NC={info={normally closed}}] ++(2,0);
		  \end{tikzpicture}
		\end{center}
		\begin{center}
		  \begin{tikzpicture}
		    \draw(0,0) to [switch, label={normally open}] ++(2,0);
		    \draw(4,0) to [opening switch, label={normally closed}] ++(2,0);
		  \end{tikzpicture}
		\end{center}
    #+end_export

* Latching circuit
** Intermezzo - An electrical circuit with memory

*** Latching circuit
    :PROPERTIES:
    :BEAMER_col: 0.6
    :BEAMER_env: block
    :END:      

    #+begin_export latex
            \begin{center}
                     \begin{tikzpicture}
                       \node at (0,0.5) {+24V};
                       \node at (6,0.5) {0V};
                       \draw (0,0) to[short, o-]  (0,-3);
                       \draw (6,0) to[short, o-](6,-3);
                       \draw (0,-0.3) to[switch, *-, label=$X$] (2,-0.3) to[ opening switch, label=$Y$, ] (4,-0.3) to[short] (4,-0.3) to[twoport, label=$R$] (6,-0.3); %\coil{$R$};
                       \draw (0,-2) to[switch, *-, label=$R$] (2,-2)  to[short,-*] (2,-0.3);
                     \end{tikzpicture}
            \end{center}

    #+end_export


*** Truth table
    :PROPERTIES:
    :BEAMER_col: 0.4
    :BEAMER_env: block
    :END:      

     #+attr_latex: :align |ccc|c|
    | $X$ | $Y$ | $R_k$ | $R_{k+1}$ |
    |-----+-----+-------+-----------|
    |   0 |   0 |     0 |           |
    |   0 |   0 |     1 |           |
    |   0 |   1 |     0 |           |
    |   0 |   1 |     1 |           |
    |   1 |   0 |     0 |           |
    |   1 |   0 |     1 |           |
    |   1 |   1 |     0 |           |
    |   1 |   1 |     1 |           |
    |-----+-----+-------+-----------|

#    \begin{align*}
#     R_{k+1} &= \not{X}\not{Y}R_k  + X\not{Y}\not{R_k} + X\not{Y}R_k\\ 
#     &= \not{X}\not{Y}R_k + X\not{Y}
#    \end{align*}

** An electrical circuit with memory                               :noexport:

*** Latching circuit
    :PROPERTIES:
    :BEAMER_col: 0.6
    :BEAMER_env: block
    :END:      

     #+begin_export latex
            \begin{center}
                     \begin{tikzpicture}
                       \node at (0,0.5) {+24V};
                       \node at (6,0.5) {0V};
                       \draw (0,0) to[short, o-]  (0,-3);
                       \draw (6,0) to[short, o-](6,-3);
                       \draw (0,-0.3) to[switch, *-, label=$X$] (2,-0.3) to[ opening switch, label=$Y$, ] (4,-0.3) to[short] (4,-0.3) \coil{$R$};
                       \draw (0,-2) to[switch, *-, label=$R$] (2,-2)  to[short,-*] (2,-0.3);
                     \end{tikzpicture}
            \end{center}
     #+end_export

*** Truth table
    :PROPERTIES:
    :BEAMER_col: 0.4
    :BEAMER_env: block
    :END:      

     #+attr_latex: :align |ccc|c|
    | $X$ | $Y$ | $R_k$ | $R_{k+1}$ |
    |-----+-----+-------+-----------|
    |   0 |   0 |     0 |         0 |
    |   0 |   0 |     1 |         1 |
    |   0 |   1 |     0 |         0 |
    |   0 |   1 |     1 |         0 |
    |   1 |   0 |     0 |         1 |
    |   1 |   0 |     1 |         1 |
    |   1 |   1 |     0 |         0 |
    |   1 |   1 |     1 |         0 |
    |-----+-----+-------+-----------|

#    \begin{align*}
#     R_{k+1} &= \not{X}\not{Y}R_k  + X\not{Y}\not{R_k} + X\not{Y}R_k\\ 
#     &= \not{X}\not{Y}R_k + X\not{Y}
#    \end{align*}

* The lab assignment

** The lab assignment
#+BEGIN_CENTER 
 \includegraphics[width=0.4\linewidth]{../../figures/cheese-pressing-two-cylinders}
  \includegraphics[width=0.58\linewidth]{../../figures/AplusBplusBminAmin}

#+END_CENTER

   #+BEGIN_CENTER 
    \includegraphics[width=0.8\linewidth]{../../figures/logic-control-loop}
   #+END_CENTER


** Implementing the sequence A+B+B-A-
#+BEGIN_CENTER 
 \includegraphics[width=0.8\linewidth]{../../figures/AplusBplusBminAmin}
#+END_CENTER

** Implementing the sequence A+B+B-A-, control signal

   #+begin_center
 \includegraphics[width=0.42\linewidth]{../../figures/AplBplBminAmin-pneum.png}
 \includegraphics[width=0.58\linewidth]{../../figures/logic-control-loop}
   #+end_center

*** Control signal 
    \[ u = \begin{bmatrix} u_A+ & u_A- & u_B+ & u_B- \end{bmatrix}^T, \]
    with
    \[ u_A+ = \begin{cases} 0 & \text{Solenoid extending A is not activated}\\
                               1&\text{Solenoid extending A is activated}\\
              \end{cases}
   \]
   etc.
#
#    \[ u_A- = \begin{cases} 0 & \text{Solenoid retracting A is not activated}\\
#                               1&\text{Solenoid retracting A is activated}\\
#              \end{cases}
#   \]
#   Similar for B.

** Implementing the sequence A+B+B-A-, state variables
#+BEGIN_CENTER 
 \includegraphics[width=0.3\linewidth]{../../figures/AplusBplusBminAmin}
 \includegraphics[width=0.68\linewidth]{../../figures/logic-control-loop}
#+END_CENTER

*** State variables (naive)
    \[ x = \begin{bmatrix} x_A & x_B \end{bmatrix}^T, \]
    with
    \[ x_{\{A,B\}} = \begin{cases} 0 & \text{Cylinder \{A,B\} retracted}\\
                               1& \text{Cylinder \{A,B\} extended}
                 \end{cases}
   \]

** Implementing the sequence A+B+B-A-, control law
#+BEGIN_CENTER 
 \includegraphics[width=0.3\linewidth]{../../figures/AplusBplusBminAmin}
 \includegraphics[width=0.68\linewidth]{../../figures/logic-control-loop}
#+END_CENTER
*** Control law (problematic)
    Ignoring input signal $u_c$ (no start/stop buttons). Movement should be cyclic

     #+attr_latex: :align |cc|cccc|
     |-------+-------+--------+--------+--------+--------|
     | $x_A$ | $x_B$ | $u_A+$ | $u_A-$ | $u_B+$ | $u_B-$ |
     |-------+-------+--------+--------+--------+--------|
     |     0 |     0 |        |        |        |        |
     |     1 |     0 |        |        |        |        |
     |     1 |     1 |        |        |        |        |
     |     0 |     1 |        |        |        |        |
     |-------+-------+--------+--------+--------+--------|

    

** Implementing the sequence A+B+B-A-, control law
#+BEGIN_CENTER 
 \includegraphics[width=0.3\linewidth]{../../figures/AplusBplusBminAmin}
 \includegraphics[width=0.68\linewidth]{../../figures/logic-control-loop}
#+END_CENTER
*** Control law (problematic)
    Ignoring input signal $u_c$. Movement should be cyclic

     #+attr_latex: :align |cc|cccc|
     |-------+-------+--------+--------+--------+--------|
     | $x_A$ | $x_B$ | $u_A+$ | $u_A-$ | $u_B+$ | $u_B-$ |
     |-------+-------+--------+--------+--------+--------|
     |     0 |     0 |      1 |      0 |      0 |      0 |
     |     1 |     0 |      0 | 1 or 0 | 0 or 1 |      0 |
     |     1 |     1 |      0 |      0 |      0 |      1 |
     |   (0) |   (1) |      0 |      0 |      0 |      1 |
     |-------+-------+--------+--------+--------+--------|

    

** Implementing the sequence A+B+B-A-, the problem
   *The correct control signal (action) is not uniquely defined by the position of the cylinders*
#+BEGIN_CENTER 
 \includegraphics[width=0.5\linewidth]{../../figures/AplusBplusBminAmin}\\
 \includegraphics[width=0.8\linewidth]{../../figures/logic-control-loop}
#+END_CENTER

** Implementing the sequence A+B+|B-A-
   *Dividing the sequence into groups (a.k.a. cascade method)*
   \[ \underbrace{\text{A+B+}}_{\text{Group 1}}| \underbrace{\text{B-A-}}_{\text{Group 2}} \]
   #+begin_export latex
   \begin{center}
  \begin{tikzpicture}
  %\pgfplotsset{set layers=default}
    \begin{groupplot} [
      group style={
        group name=timeplot,
        group size=1 by 2,
        xlabels at=all,
        horizontal sep=1cm,
        vertical sep=1cm,
      }, 
      clip=false,
      height=3.3cm, width=9.3cm,
      axis line style={->},
      axis lines=left,
      xlabel={time },
      ylabel={},
      ytick={0,1},
      xtick={0,1,2,3,4},
      % grid=both,
      % xtick=\empty,
      % ytick=\XNOLL,
      % yticklabel=$x_0$,
      ]
      \nextgroupplot [ylabel={A},]
      \addplot[red, no marks,ultra thick,] coordinates {(0,0) (1,1) (2, 1) (3,1) (4, 0)};
      \draw[color=black!10, fill=black!10] (axis cs: 0.02,0.02) rectangle (axis cs: 2,1);
      \node at (axis cs: 1, 0.5) {Group 1};
      \draw[color=black!40, fill=black!40] (axis cs: 2,0.02) rectangle (axis cs: 4,1);
      \node at (axis cs: 3, 0.5) {Group 2};
      \addplot[red, no marks,ultra thick,] coordinates {(0,0) (1,1) (2, 1) (3,1) (4, 0)};

      \nextgroupplot [ylabel={B},]
      \draw[color=black!10, fill=black!10] (axis cs: 0.02,0.02) rectangle (axis cs: 2,1);
      \node at (axis cs: 1, 0.5) {Group 1};
      \draw[color=black!40, fill=black!40] (axis cs: 2,0.02) rectangle (axis cs: 4,1);
      \node at (axis cs: 3, 0.5) {Group 2};
      \addplot[red, no marks,ultra thick,] coordinates {(0,0) (1,0) (2, 1) (3,0) (4, 0)};
    \end{groupplot}
  \end{tikzpicture}
    \end{center}
   #+end_export


** Implementing the sequence A+B+|B-A-, state variables
*** State variables (better)
    :PROPERTIES:
    :BEAMER_col: 0.45
    :BEAMER_env: block
    :END:      


    \[ x = \begin{bmatrix} x_A & x_B & x_{G1} & x_{G2}\end{bmatrix}^T, \]
    with
    \begin{align*}
     x_{\{A,B\}} &= \begin{cases} 0 & \text{Cylinder \{A,B\} retracted}\\
                               1& \text{Cylinder \{A,B\} extended}
                 \end{cases}\\
    x_{Gi} &= \begin{cases} 0 & \text{Group \(i\) not active}\\
                               1& \text{Group \(i\) active}
                 \end{cases}
   \end{align*}

*** State transitions
    :PROPERTIES:
    :BEAMER_col: 0.55
    :BEAMER_env: block
    :END:      

   #+begin_export latex
   \begin{center}
  \begin{tikzpicture}
  %\pgfplotsset{set layers=default}
    \begin{groupplot} [
      group style={
        group name=timeplot,
        group size=1 by 4,
        xlabels at=edge bottom,
        horizontal sep=1cm,
        vertical sep=8mm,
      }, 
      clip=false,
      height=2.6cm, width=7.3cm,
      axis line style={->},
      axis lines=left,
      xlabel={time },
      ylabel={},
      ytick={0,1},
      xtick={0,1,2,3,4},
      % grid=both,
      % xtick=\empty,
      % ytick=\XNOLL,
      % yticklabel=$x_0$,
      ]
      \nextgroupplot [ylabel={$x_A$},]
      \addplot[red, no marks,ultra thick,] coordinates {(0,0) (1,1) (2, 1) (3,1) (4, 0)};
      \draw[color=black!10, fill=black!10] (axis cs: 0.02,0.02) rectangle (axis cs: 2,1);
      \node at (axis cs: 1, 0.5) {Group 1};
      \draw[color=black!40, fill=black!40] (axis cs: 2,0.02) rectangle (axis cs: 4,1);
      \node at (axis cs: 3, 0.5) {Group 2};
      \addplot[red, no marks,ultra thick,] coordinates {(0,0) (1,1) (2, 1) (3,1) (4, 0)};

      \nextgroupplot [ylabel={$x_B$},]
      \draw[color=black!10, fill=black!10] (axis cs: 0.02,0.02) rectangle (axis cs: 2,1);
      \node at (axis cs: 1, 0.5) {Group 1};
      \draw[color=black!40, fill=black!40] (axis cs: 2,0.02) rectangle (axis cs: 4,1);
      \node at (axis cs: 3, 0.5) {Group 2};
      \addplot[red, no marks,ultra thick,] coordinates {(0,0) (1,0) (2, 1) (3,0) (4, 0)};

      \nextgroupplot [ylabel={$x_{G1}$},]
      \draw[color=black!10, fill=black!10] (axis cs: 0.02,0.02) rectangle (axis cs: 2,1);
      \node at (axis cs: 1, 0.5) {Group 1};
      \draw[color=black!40, fill=black!40] (axis cs: 2,0.02) rectangle (axis cs: 4,1);
      \node at (axis cs: 3, 0.5) {Group 2};
      \addplot[red, no marks,ultra thick,] coordinates {(0,1) (1, 1) (2,0) (3, 0) (4,1)};

      \nextgroupplot [ylabel={$x_{G2}$},]
      \draw[color=black!10, fill=black!10] (axis cs: 0.02,0.02) rectangle (axis cs: 2,1);
      \node at (axis cs: 1, 0.5) {Group 1};
      \draw[color=black!40, fill=black!40] (axis cs: 2,0.02) rectangle (axis cs: 4,1);
      \node at (axis cs: 3, 0.5) {Group 2};
      \addplot[red, no marks,ultra thick,] coordinates {(0,0) (1, 0) (2,1) (3, 1) (4,0)};
    \end{groupplot}
  \end{tikzpicture}
    \end{center}
   #+end_export
    
** Implementing the sequence A+B+|B-A-, control law
*** State transitions
    :PROPERTIES:
    :BEAMER_col: 0.38
    :BEAMER_env: block
    :END:      
   #+begin_export latex
   \begin{center}
  \begin{tikzpicture}
  %\pgfplotsset{set layers=default}
    \begin{groupplot} [
      group style={
        group name=timeplot,
        group size=1 by 4,
        xlabels at=edge bottom,
        horizontal sep=1cm,
        vertical sep=8mm,
      }, 
      clip=false,
      height=2.2cm, width=5.3cm,
      axis line style={->},
      axis lines=left,
      xlabel={time },
      ylabel={},
      ytick={0,1},
      xtick={0,1,2,3,4},
      % grid=both,
      % xtick=\empty,
      % ytick=\XNOLL,
      % yticklabel=$x_0$,
      ]
      \nextgroupplot [ylabel={$x_A$},]
      \addplot[red, no marks,ultra thick,] coordinates {(0,0) (1,1) (2, 1) (3,1) (4, 0)};
      \draw[color=black!10, fill=black!10] (axis cs: 0.02,0.02) rectangle (axis cs: 2,1);
      \node at (axis cs: 1, 0.5) {Group 1};
      \draw[color=black!40, fill=black!40] (axis cs: 2,0.02) rectangle (axis cs: 4,1);
      \node at (axis cs: 3, 0.5) {Group 2};
      \addplot[red, no marks,ultra thick,] coordinates {(0,0) (1,1) (2, 1) (3,1) (4, 0)};

      \nextgroupplot [ylabel={$x_B$},]
      \draw[color=black!10, fill=black!10] (axis cs: 0.02,0.02) rectangle (axis cs: 2,1);
      \node at (axis cs: 1, 0.5) {Group 1};
      \draw[color=black!40, fill=black!40] (axis cs: 2,0.02) rectangle (axis cs: 4,1);
      \node at (axis cs: 3, 0.5) {Group 2};
      \addplot[red, no marks,ultra thick,] coordinates {(0,0) (1,0) (2, 1) (3,0) (4, 0)};

      \nextgroupplot [ylabel={$x_{G1}$},]
      \draw[color=black!10, fill=black!10] (axis cs: 0.02,0.02) rectangle (axis cs: 2,1);
      \node at (axis cs: 1, 0.5) {Group 1};
      \draw[color=black!40, fill=black!40] (axis cs: 2,0.02) rectangle (axis cs: 4,1);
      \node at (axis cs: 3, 0.5) {Group 2};
      \addplot[red, no marks,ultra thick,] coordinates {(0,1) (1, 1) (2,0) (3, 0) (4,1)};

      \nextgroupplot [ylabel={$x_{G2}$},]
      \draw[color=black!10, fill=black!10] (axis cs: 0.02,0.02) rectangle (axis cs: 2,1);
      \node at (axis cs: 1, 0.5) {Group 1};
      \draw[color=black!40, fill=black!40] (axis cs: 2,0.02) rectangle (axis cs: 4,1);
      \node at (axis cs: 3, 0.5) {Group 2};
      \addplot[red, no marks,ultra thick,] coordinates {(0,0) (1, 0) (2,1) (3, 1) (4,0)};
    \end{groupplot}
  \end{tikzpicture}
    \end{center}
   #+end_export


*** Control law
    :PROPERTIES:
    :BEAMER_col: 0.62
    :BEAMER_env: block
    :END:      

     #+attr_latex: :align |cccc|cccc|
     |-------+-------+----------+----------+--------+--------+--------+--------|
     | $x_A$ | $x_B$ | $x_{G1}$ | $x_{G2}$ | $u_A+$ | $u_A-$ | $u_B+$ | $u_B-$ |
     |-------+-------+----------+----------+--------+--------+--------+--------|
     |     0 |     0 |        1 |   0      |        |        |        |        |
     |     1 |     0 |        1 |   0      |        |        |        |        |
     |     1 |     1 |        0 |   1      |        |        |        |        |
     |     1 |     0 |        0 |   1      |        |        |        |        |
     |-------+-------+----------+----------+--------+--------+--------+--------|

    
** Implementing the control law
   
    #+begin_export latex
            \begin{center}
                     \begin{tikzpicture}
                       \node at (-2,0.5) {+24V};
                       \node at (8,0.5) {0V};
                       \draw (-2,0) to[short, o-]  (-2,-7);
                       \draw (8,0) to[short, o-](8,-7);
		       \draw (6, -0.5) to[twoport, label={$u_{A+}$}] (8,-0.5); %\coil{$u_{A+}$};
                       \draw (6,-2.5) to[twoport, label={$u_{A-}$}] (8,-2.5);%\coil{$u_{A-}$};
		       \draw (6, -4.5) to[twoport, label={$u_{B+}$}] (8,-4.5);%\coil{$u_{B+}$};
                       \draw (6,-6.5) to[twoport, label={$u_{B-}$}] (8,-6.5);% \coil{$u_{B-}$};
                  \end{tikzpicture}
            \end{center}

    #+end_export


** Implementing the group transitions 
   
    #+begin_export latex
            \begin{center}
                     \begin{tikzpicture}
                       \node at (-2,0.5) {+24V};
                       \node at (8,0.5) {0V};
                       \draw (-2,0) to[short, o-]  (-2,-7);
                       \draw (8,0) to[short, o-](8,-7);
		       \draw (6, -0.5) to[twoport, label={$x_{G1}$}] (8,-0.5);%\coil{$x_{G1}$};
		       \draw (6, -4.5) to[twoport, label={$x_{G2}$}] (8,-4.5);%\coil{$x_{G2}$};
		       \draw (-2,-2) to[switch, *-, label={$x_{G1}$}] (1,-2);
		       \draw (-2,-6) to[switch, *-, label={$x_{G2}$}] (1,-6);
                  \end{tikzpicture}
            \end{center}

    #+end_export


   
** Implementing the proximity sensor circuit
   
    #+begin_export latex
    \begin{center}
    \includegraphics[height=0.9\textheight]{sensor-circuit}
    \end{center}

    #+end_export


   
** For the report                                                  :noexport:

   - Truth table for the control law
   - Control law as boolean expression
   - Circuit diagram for the controller
   - Screen shot and short video showing working solution in FluidSim
